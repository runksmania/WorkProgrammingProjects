#include <iostream>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <algorithm>

using namespace std;

class StringSplitter
{
public:

	//Accepts a string and a delimiter.  Will use items_found to return the number
	//of items found as well as an array of strings where each element is a piece of
	//the original string.
	static vector<string> split(string text, string delimiter)
	{
		//vectors are dynamically expanding arrays
		vector<string> pieces;

		//find the first delimiter
		int location = text.find(delimiter);

		//we are starting at the beginning of our string
		int start = 0;

		//go until we have no more delimiters
		while(location != string::npos)
		{
			//add the current piece to our list of pieces
			string piece = text.substr(start, location - start);
			pieces.push_back(piece);

			//update our index markers for the next round
			start = location + 1;
			location = text.find(delimiter, start);
		}

		//at the end of our loop, we're going to have one trailing piece to take care of.
		//handle that now.
		string piece = text.substr(start, location - start);
		pieces.push_back(piece);
		return pieces;
	}
};

class Customer
{
  private:
    string _id;
    string _name;
    int _numPrizesWon;
    vector<string> _prizesWonList;
    
    //Disable default constructor.
    Customer()
    {
        //Deliberately left empty.
    }
    
  public:
    Customer(string name, string id)
    {
        _name = name;
        _id = id;
        _numPrizesWon = 0;
        _prizesWonList = vector<string>();
    }
    
    Customer(string name, string id, int numPrizesWon, vector<string> prizesWonList)
    {
        _name = name;
        _id = id;
        _numPrizesWon = numPrizesWon;
        _prizesWonList = prizesWonList;
    }
    
    string getId()
    {
        return _id;
    }
    
    void setId(string id)
    {
        _id = id;
    }
    
    string getName()
    {
        return _name;
    }
    
    void setName(string name)
    {
        _name = name;
    }
    
    int getNumPrizesWon()
    {
        return _numPrizesWon;
    }
    
    void setNumPrizesWon(int numPrizesWon)
    {
        _numPrizesWon = numPrizesWon;
    }
    
    vector<string> getPrizesWonList()
    {
        return _prizesWonList;
    }
    
    void setPrizesWonList(vector<string> prizesWonList)
    {
        _prizesWonList = prizesWonList;
    }
    
};

class Prize
{
    private:
        string _value;
        string _prize;
        bool _beenWon;
        
        //Disable default constructor.
        Prize()
        {
            //Deliberately left empty.
        }
    
    public:
        Prize(string prize, string value, bool beenWon)
        {
            _value = value;
            _prize = prize;
            _beenWon = beenWon;
        }
        
        string getValue()
        {
            return _value;
        }
    
        string getPrize()
        {
            return _prize;
        }
        
        bool getBeenWon()
        {
            return _beenWon;
        }
    
};

class TotalPrizes
{
    private:
        vector<vector<Prize>> _prizeList;
    
    public:
        TotalPrizes()
        {
            for(auto prize : _prizeList)
            {
                prize = vector<Prize>();
            }
        }
        
        int getTotalPrizeListSize()
        {
            return _prizeList.size();
        }
        
        vector<Prize> getTierPrizeList(int tierNum)
        {
            return _prizeList[tierNum];
        }
        
        void setTierPrizeList(int tierNum, vector<Prize> tierPrizeList)
        {
            _prizeList[tierNum] = tierPrizeList;
        }
        
};

unordered_map<string, Customer*> loadCustomerFile(string fileToLoad)
{
    unordered_map<string, Customer*> custHash;
    ifstream inputFile;
    
    inputFile.open(fileToLoad);
    
    if(inputFile.good())
    {
        while(inputFile.good())
        {
            string currentLine, prizesWonLine;
            vector<string> lineSplit, prizesWonSplit;
            
            getline(inputFile, currentLine);
            //vector<string> lineSplit = StringSplitter::split(currentLine, ",");
            getline(inputFile, prizesWonLine);
            //vector<string> prizesWonSplit = StringSplitter::split(currentLine, ",");
            
            Customer *customer = new Customer(lineSplit[0], lineSplit[1], stoi(lineSplit[2]), prizesWonSplit);
            custHash[customer->getName()] = customer;
        }
    }
    else
    {
        cout << "Error reading file.\n";
    }
    
    inputFile.close();
    
    return custHash;
}

void saveCustomerFile(string filename, unordered_map<string, Customer*> custHash)
{
    vector<string> custNames;
    ofstream outputFile;
    outputFile.open(filename);
    
    //Alphabatize customers.
    for(auto cust : custHash)
    {
        custNames.push_back(cust.second->getName());
    }
    
    sort(custNames.begin(), custNames.end());
    
    if(outputFile.good())
    {
        for(auto cust : custNames)
        {
            Customer *customer = custHash[cust];
            vector<string> prizesWon = customer->getPrizesWonList();
            
            outputFile << customer->getName() << "," 
                << customer->getId() << ","
                << customer->getNumPrizesWon() << endl;
            
            for(auto prize : prizesWon)
            {
                if(prize == prizesWon[prizesWon.size() - 1])
                {
                    outputFile << prize;
                }
                else
                {
                    outputFile << prize << ",";
                }
            }
            outputFile << endl;
        }
    }
    else
    {
        cout << "Error writing file.\n";
    }
}

unordered_map<string, Customer*> readCustomerFile()
{
    unordered_map<string, Customer*> custHash;
    
    string currentLine, prizesWonLine;
    vector<string> lineSplit, prizesWonSplit;
    
    for(int i = 0; i < 3; i++)
    {
        getline(cin, currentLine);
        lineSplit = StringSplitter::split(currentLine, ",");
        getline(cin, prizesWonLine);
        prizesWonSplit = StringSplitter::split(prizesWonLine, ",");
           
        Customer *customer = new Customer(lineSplit[0], lineSplit[1], stoi(lineSplit[2]), prizesWonSplit);
        custHash[customer->getName()] = customer;
    }
    
    return custHash;
}

void writeCustomerFile(unordered_map<string, Customer*> custHash)
{
    vector<string> custNames;
    
    //Alphabatize customers.
    for(auto cust : custHash)
    {
        custNames.push_back(cust.second->getName());
    }
    
    sort(custNames.begin(), custNames.end());
    
    for(auto cust : custNames)
    {
        Customer *customer = custHash[cust];
        vector<string> prizesWon = customer->getPrizesWonList();
        
        cout << customer->getName() << "," 
            << customer->getId() << ","
            << customer->getNumPrizesWon() << endl;
        
        for(auto prize : prizesWon)
        {
            if(prize == prizesWon[prizesWon.size() - 1])
            {
                cout << prize;
            }
            else
            {
                cout << prize << ",";
            }
        }
        cout << endl;
    }
}

TotalPrizes loadPrizeFile(string filename)
{
    TotalPrizes totalPrizes();
    ifstream inputFile;
    inputFile.open(filename);
    
    if(inputFile.good())
    {
        while(inputFile.good())
        {
            vector<Prize> tierPrizes;
            string currentLine;
            
            getline(inputFile, currentLine);
            vector<string> lineSplit = StringSplitter::split(currentLine, ",");
            
            for(int i = 0; i < lineSplit.size(); i += 3)
            {
                bool beenWon = false;
                if(lineSplit[i + 2] == "1")
                {
                    beenWon = true;
                }
                
                Prize prize(lineSplit[i], lineSplit[i + 1], beenWon);
                
                tierPrizes.push_back(prize);
            }
        }
    }
    else
    {
        cout << "Error reading file.\n";
    }
}

void savePrizeFile(string filename, TotalPrizes totalPrizes)
{
    ofstream outputFile;
    outputFile.open(filename);
    
    if(outputFile.good())
    {
        for(int i = 0; i < totalPrizes.getTotalPrizeListSize(); i++)
        {
            vector<Prize> tierPrizeList = totalPrizes.getTierPrizeList(i);
            
            for(int j = 0; j < tierPrizeList.size(); j++)
            {
                Prize prize = tierPrizeList[j];
                string beenWon = "0";
                
                if(prize.getBeenWon())
                {
                    beenWon = "1";
                }
                
                if(j == tierPrizeList.size() - 1)
                {
                    outputFile << prize.getPrize() << ","
                        << prize.getValue() << ","
                        << beenWon << endl;
                }
                else
                {
                    outputFile << prize.getPrize() << ","
                        << prize.getValue() << ","
                        << beenWon << ",";
                }
                
            }
        }
    }
    else
    {
        cout << "Error writing file.\n";
    }
}

int main() 
{
    //unordered_map<string, Customer*> customers = readCustomerFile();
    //writeCustomerFile(customers);
    
	return 0;
}
